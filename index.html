<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>To: ËáßÂÆùÂÆù - New Year Surprise</title>

    <style>
        /* Â≠ó‰ΩìÂºïÂÖ• */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@300;600&display=swap');

        /* ÂÖ®Â±ÄÂü∫Á°Ä */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Noto Serif SC', serif;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* WebGL ÂÆπÂô® */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI ‰∫§‰∫íÂ±Ç */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }

        /* 1. Ëµ∑ÂßãÈ°µ */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #fff0f5 0%, #fff5ee 100%);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            transition: opacity 1.5s ease-out, visibility 1.5s;
            overflow: hidden;
        }

        .falling-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .falling-item {
            position: absolute;
            top: -10%;
            color: #ffb7c5;
            font-size: 20px;
            opacity: 0.8;
            animation-name: fall;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
        }

        @keyframes fall {
            0% {
                transform: translateY(0) rotate(0deg);
                opacity: 0.8;
            }

            100% {
                transform: translateY(110vh) rotate(360deg);
                opacity: 0;
            }
        }

        .title-box {
            text-align: center;
            z-index: 2;
        }

        .title-box h1 {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: clamp(3.5rem, 12vw, 7rem);
            margin: 0;
            color: #c06c84;
            text-shadow: 2px 2px 0px #fff, 0 0 20px rgba(255, 182, 193, 0.5);
            font-weight: 400;
            letter-spacing: 5px;
        }

        .title-box p {
            font-family: 'Cinzel', serif;
            font-size: clamp(1rem, 3vw, 1.5rem);
            color: #6c5b7b;
            margin-top: 15px;
            margin-bottom: 50px;
            letter-spacing: 6px;
            text-transform: uppercase;
        }

        #btn-start-experience {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid #c06c84;
            color: #c06c84;
            padding: 12px 50px;
            font-size: 1.1rem;
            font-family: 'Noto Serif SC', serif;
            cursor: pointer;
            transition: all 0.4s ease;
            letter-spacing: 3px;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(192, 108, 132, 0.15);
            backdrop-filter: blur(5px);
        }

        #btn-start-experience:hover {
            background: #c06c84;
            color: #fff;
            box-shadow: 0 5px 20px rgba(192, 108, 132, 0.4);
            transform: translateY(-2px);
        }

        .fade-out {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        /* 2. ÊÅãÁà±ËÆ°Êó∂Âô® */
        #love-timer-container {
            position: absolute;
            top: 25px;
            left: 25px;
            z-index: 20;
            pointer-events: none;
            display: none;
            animation: fadeIn 2s ease forwards;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .love-text {
            font-family: 'Ma Shan Zheng', cursive;
            color: #ffdde1;
            font-size: clamp(1.2rem, 2.5vw, 1.8rem);
            text-shadow: 0 0 10px rgba(255, 105, 180, 0.6);
            letter-spacing: 2px;
            line-height: 1.5;
        }

        .love-time-numbers {
            font-family: 'Cinzel', serif;
            font-weight: 600;
            color: #d4af37;
            margin: 0 5px;
        }

        /* 3. Âè≥‰∏äËßíÊåâÈíÆÁªÑ */
        #top-right-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 30;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(212, 175, 55, 0.3);
            color: #d4af37;
            width: 110px;
            padding: 8px 0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Noto Serif SC', serif;
            font-size: 13px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.3s ease;
        }

        .control-btn:hover,
        .control-btn.active {
            background: rgba(212, 175, 55, 0.2);
            border-color: rgba(212, 175, 55, 0.8);
            color: #fff;
        }

        #file-input,
        #music-input {
            display: none;
        }

        /* 4. ÊëÑÂÉèÂ§¥Ê†∑Âºè (ÂÖ≥ÈîÆ‰øÆÊîπÔºöÁßªÈô§ÂÆΩÈ´ò transitionÔºå‰øùÁïô opacity transition) */
        #webcam-wrapper {
            position: absolute;
            bottom: 20px;
            right: 20px;
            opacity: 0;
            pointer-events: auto;
            border: 1px solid rgba(212, 175, 55, 0.5);
            border-radius: 12px;
            background: #000;
            z-index: 50;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Âè™ÂØπÈÄèÊòéÂ∫¶ÂÅöËøáÊ∏°ÔºåË∞ÉÊï¥Â§ßÂ∞èÊó∂ÈúÄË¶ÅÂÆûÊó∂ÂìçÂ∫îÔºåÊâÄ‰ª•‰∏çÂÅöËøáÊ∏° */
            transition: opacity 0.5s;
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.2);
            overflow: hidden;
            cursor: pointer;
            /* ÂàùÂßãÂ∞∫ÂØ∏ */
            width: 280px;
            height: 210px;
        }

        /* ÈïøÊåâÊ≠£Âú®Ë∞ÉÊï¥Â§ßÂ∞èÊó∂ÁöÑÊ†∑Âºè */
        #webcam-wrapper.resizing {
            border-color: #fff;
            /* ËæπÊ°ÜÂèòÁôΩÊèêÁ§∫ */
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            cursor: e-resize;
        }

        #webcam-wrapper {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #webcam {
            display: none;
        }

        #webcam-preview {
            display: block;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        .download-btn-container {
            display: none;
        }

        /* 5. ‰π¶‰ø°Â±ïÁ§∫Â±Ç */
        #letter-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 150;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(3px);
            display: none;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 1.5s ease;
        }

        .letter-paper {
            height: 75%;
            aspect-ratio: 3/4;
            background: linear-gradient(160deg, rgba(20, 10, 30, 0.85) 0%, rgba(40, 10, 15, 0.8) 100%);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(212, 175, 55, 0.5);
            box-shadow: 0 0 50px rgba(212, 175, 55, 0.2), inset 0 0 30px rgba(212, 175, 55, 0.05);
            border-radius: 12px;
            padding: 6vh;
            box-sizing: border-box;
            position: relative;
            display: flex;
            flex-direction: column;
            transform: translateY(20px);
            transition: transform 1.5s ease-out;
            background-image:
                radial-gradient(white, rgba(255, 255, 255, .3) 2px, transparent 5px),
                radial-gradient(white, rgba(255, 255, 255, .2) 1px, transparent 3px),
                radial-gradient(rgba(212, 175, 55, 0.5), transparent 2px);
            background-size: 250px 250px, 150px 150px, 80px 80px;
            background-position: 0 0, 40px 60px, 100px 100px;
        }

        .letter-paper::before,
        .letter-paper::after {
            content: '';
            position: absolute;
            width: 40px;
            height: 40px;
            pointer-events: none;
            opacity: 0.7;
            border-color: #d4af37;
            border-style: solid;
        }

        .letter-paper::before {
            top: 15px;
            left: 15px;
            border-width: 2px 0 0 2px;
        }

        .letter-paper::after {
            bottom: 15px;
            right: 15px;
            border-width: 0 2px 2px 0;
        }

        .letter-content {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: clamp(20px, 3vh, 28px);
            line-height: 2;
            color: #ffe4c4;
            text-shadow: 0 0 5px rgba(212, 175, 55, 0.5);
            white-space: pre-wrap;
            overflow-y: auto;
            flex: 1;
        }

        .letter-content::-webkit-scrollbar-thumb {
            background: rgba(212, 175, 55, 0.5);
        }

        .letter-content::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 175, 55, 0.8);
        }

        .letter-close-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 32px;
            height: 32px;
            border: 1px solid rgba(212, 175, 55, 0.6);
            border-radius: 50%;
            color: rgba(212, 175, 55, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 20px;
            transition: 0.3s;
            background: rgba(0, 0, 0, 0.2);
        }

        .letter-close-btn:hover {
            border-color: #fff;
            color: #fff;
            background: rgba(212, 175, 55, 0.3);
        }

        #loader {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fff0f5;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: opacity 1s;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(192, 108, 132, 0.2);
            border-top: 3px solid #c06c84;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>

<body>
    <div id="loader">
        <div class="spinner"></div>
    </div>

    <div id="start-screen">
        <div class="falling-container" id="falling-container"></div>
        <div class="title-box">
            <h1>‰∫≤Áà±ÁöÑËáßÂÆùÂÆù</h1>
            <p>Happy New Year & Forever Love</p>
            <button id="btn-start-experience">ÂºÄÂêØÊàë‰ª¨ÁöÑÊòüÁ©∫</button>
        </div>
    </div>

    <div id="love-timer-container">
        <div class="love-text" id="love-timer-text">
            ‰∏éËáßÂÆùÂÆùÂú®‰∏ÄËµ∑ÁöÑÁ¨¨ <span class="love-time-numbers">0</span> Â§©
            <span class="love-time-numbers">0</span> Êó∂
            <span class="love-time-numbers">0</span> ÂàÜ
            <span class="love-time-numbers">0</span> Áßí
        </div>
    </div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div id="top-right-controls">
            <button id="btn-toggle-camera" class="control-btn active">ÂÖ≥Èó≠ÊëÑÂÉèÂ§¥</button>
            <button id="btn-slideshow" class="control-btn">ÁÇπÊª¥Áû¨Èó¥</button>
            <button id="btn-fullscreen" class="control-btn">ÂÖ®Â±èÊòæÁ§∫</button>
        </div>
    </div>

    <div id="letter-overlay">
        <div class="letter-paper">
            <div class="letter-close-btn" id="btn-close-letter-mode">√ó</div>
            <div class="letter-content" id="letter-content-display"></div>
        </div>
    </div>

    <div id="webcam-wrapper" oncontextmenu="return false;">
        <video id="webcam" autoplay playsinline webkit-playsinline></video>
        <canvas id="webcam-preview"></canvas>
    </div>

    <audio id="bg-music" loop crossorigin="anonymous"></audio>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { FilesetResolver, HandLandmarker, DrawingUtils } from '@mediapipe/tasks-vision';

        // ==========================================
        // 1. CONFIG
        // ==========================================
        const CONFIG = {
            colors: { bg: 0x020202, gold: 0xffd700, red: 0x880000, green: 0x004400, pink: 0xff69b4, white: 0xffffff },
            particles: { count: 1800, dustCount: 1500, treeHeight: 28, treeRadius: 9 },
            camera: { z: 55 },
            gestures: { pinchThreshold: 0.05, palmOpenThreshold: 0.35, sensitivity: 6.0 }
        };
        const LOCAL_ASSETS = {
            music: 'https://cdn.pixabay.com/download/audio/2022/11/22/audio_febc508520.mp3?filename=christmas-magic-127393.mp3'
        };

        // ==========================================
        // 2. STATE
        // ==========================================
        const STATE = {
            mode: 'WAITING',
            isCameraActive: true,
            videoAspectRatio: 4 / 3,
            focusTarget: null,
            currentPhotoIndex: -1,
            currentThemeIndex: 0,
            lastGesture: null,
            gestureDebounceTimer: 0,
            scatterScale: 1.0,
            gestureBaseSpread: null,
            hand: { detected: false, x: 0, y: 0 },
            mouse: { x: 0, y: 0 },
            rotation: { x: 0, y: 0 },
            spinVel: { x: 0, y: 0 },
            time: 0,
            wasPointing: false,
            palmCenter: { x: 0.5, y: 0.5 },
            hasPalmCenter: false,
            starMesh: null,
            letterContent: "‰∫≤Áà±ÁöÑËáßÂÆùÂÆùÔºö\n\n2025ÊòØ‰∏é‰Ω†ÂÖ±ÂêåÂ∫¶ËøáÁöÑÁ¨¨‰∏ÄÂπ¥ÔºåÂæÄÂêéÊó∂ÂÖâÔºåÊàëÈÉΩÊÉ≥Áâ¢Áâ¢ÁâµÁùÄ‰Ω†ÁöÑÊâã‰∏ÄËµ∑Ëøá„ÄÇÈÅáËßÅÂèØÁà±Âèà‰πêËßÇÁöÑ‰Ω†ÔºåÊòØÊàëËØªÂçö‰ª•Êù•ÊúÄÂπ∏Á¶èÁöÑ‰∫ãÊÉÖÔºåÊàëÊÉ≥ÊääËøôÊï¥ÁâáÊòüÁ©∫ÈÉΩÊëò‰∏ãÊù•ÈÄÅÁªô‰Ω†„ÄÇ\n\nÊÑøÊàëÁöÑËáßÂÆùÂÆùÊØè‰∏ÄÂ§©ÈÉΩÂ¶ÇÊñ∞Âπ¥Â§úÁöÑ‰∏áÂÆ∂ÁÅØÁÅ´‰∏ÄËà¨ÔºåÊ∏©ÊöñÊòé‰∫ÆÔºåË¢´Áà±ÁéØÁªïÔºåÊ∞∏ËøúÈó™Èó™ÂèëÂÖâÔºåËá™Â∏¶Ê∏©ÊüîÊöñÊÑèÔºåÁúºÈáåÊúâÂÖâÔºåÂøÉÈáåÊúâÁîúÔºåÂ≤ÅÂ≤ÅÊó†ÂøßÔºåÊó•Êó•ÊòéÊúó„ÄÇ\n\nÊñ∞Âπ¥Âø´‰πêÔºÅ\n\nÊ∞∏ËøúÁà±‰Ω†ÁöÑÔºå‰πñ‰πñ",
            letterTyper: null,
            letterStartTimer: null,

            // ÂπªÁÅØÁâá / Áõ∏ÂÜåÂ∑°Êºî Áä∂ÊÄÅ
            photoParticles: [],
            slideshowRotation: 0,
            slideshowSpeed: 0.2,
            isDragging: false,
            lastMouseX: 0,
            slideshowActivePhoto: null,

            // ÊëÑÂÉèÂ§¥Áº©ÊîæÁä∂ÊÄÅ
            webcamResize: {
                isResizing: false,
                startX: 0,
                startWidth: 200
            }
        };

        let scene, camera, renderer, composer, bloomPass;
        let mainGroup, starGroup, bgGroup, photoMeshGroup;
        let clock = new THREE.Clock();
        let particleSystem = [];
        let handLandmarker, video, drawingUtils, canvasCtx;
        let caneTexture; let matLib = {};

        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        // ==========================================
        // ÂàùÂßãÂåñ
        // ==========================================
        async function init() {
            createStartScreenEffects();
            startLoveTimer();

            initThree();
            setupEnvironment();
            setupLights();
            createTextures();
            createMaterials();
            createGalaxyBackground();
            createParticles();
            setupPostProcessing();
            setupEvents();
            setupLetterDisplayLogic();

            preloadLocalAssets();
            initMediaPipe().catch(console.warn);

            const loader = document.getElementById('loader');
            loader.style.opacity = 0;
            setTimeout(() => loader.style.display = 'none', 1000);

            animate();
        }

        function createStartScreenEffects() {
            const container = document.getElementById('falling-container');
            const symbols = ['üå∏', 'üíñ', '‚ú®', 'üå∏', 'ü§ç', 'üíó'];
            const count = 30;
            for (let i = 0; i < count; i++) {
                const el = document.createElement('div'); el.classList.add('falling-item');
                el.textContent = symbols[Math.floor(Math.random() * symbols.length)];
                el.style.left = Math.random() * 100 + '%';
                el.style.animationDuration = (5 + Math.random() * 10) + 's';
                el.style.animationDelay = (Math.random() * 5) + 's';
                el.style.fontSize = (15 + Math.random() * 20) + 'px';
                container.appendChild(el);
            }
        }

        function startLoveTimer() {
            const timerEl = document.getElementById('love-timer-text');
            const startDate = new Date('2025-02-01T21:37:00');
            function update() {
                const now = new Date(); const diff = now - startDate; const safeDiff = diff > 0 ? diff : 0;
                const day = Math.floor(safeDiff / (1000 * 60 * 60 * 24));
                const hour = Math.floor((safeDiff / (1000 * 60 * 60)) % 24);
                const min = Math.floor((safeDiff / (1000 * 60)) % 60);
                const sec = Math.floor((safeDiff / 1000) % 60);
                timerEl.innerHTML = `‰∏éËáßÂÆùÂÆùÂú®‰∏ÄËµ∑ÁöÑÁ¨¨ <span class="love-time-numbers">${day}</span> Â§© <span class="love-time-numbers">${hour}</span> Êó∂ <span class="love-time-numbers">${min}</span> ÂàÜ <span class="love-time-numbers">${sec}</span> Áßí`;
                requestAnimationFrame(update);
            }
            update();
        }

        async function preloadLocalAssets() {
            const loader = new THREE.TextureLoader(); const maxPhotos = 50;
            for (let i = 1; i <= maxPhotos; i++) {
                loader.load(`./photos/${i}.jpg`, (texture) => { texture.colorSpace = THREE.SRGBColorSpace; addPhotoToScene(texture); }, undefined, (err) => { });
            }
            const audioEl = document.getElementById('bg-music');
            audioEl.src = './music/bgm.mp3';
            audioEl.onerror = () => { audioEl.src = LOCAL_ASSETS.music; };
        }

        // Three.js Base
        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(CONFIG.colors.bg); scene.fog = new THREE.FogExp2(CONFIG.colors.bg, 0.012);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 2000); camera.position.set(0, 0, CONFIG.camera.z);
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", stencil: false, depth: true });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1));
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.0;
            container.appendChild(renderer.domElement);
            bgGroup = new THREE.Group(); scene.add(bgGroup);
            mainGroup = new THREE.Group(); mainGroup.rotation.x = 0.1; scene.add(mainGroup);
            starGroup = new THREE.Group(); mainGroup.add(starGroup);
            photoMeshGroup = new THREE.Group(); mainGroup.add(photoMeshGroup);
        }
        function setupEnvironment() { const pmremGenerator = new THREE.PMREMGenerator(renderer); pmremGenerator.compileEquirectangularShader(); scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture; }
        function setupLights() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.2); scene.add(ambient);
            const bottomLight = new THREE.PointLight(CONFIG.colors.gold, 3, 40); bottomLight.position.set(0, -10, 10); mainGroup.add(bottomLight);
            const spotGold = new THREE.SpotLight(0xfff0dd, 800); spotGold.position.set(40, 60, 40); spotGold.angle = 0.4; spotGold.penumbra = 0.5; spotGold.decay = 2; scene.add(spotGold);
            const spotBlue = new THREE.SpotLight(0x4455ff, 400); spotBlue.position.set(-40, 10, -30); spotBlue.lookAt(0, 0, 0); scene.add(spotBlue);
        }
        function setupPostProcessing() {
            const renderScene = new RenderPass(scene, camera);
            bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85); bloomPass.threshold = 0.85; bloomPass.strength = 0.35; bloomPass.radius = 0.25; // bloomPass.threshold = 0.7; bloomPass.strength = 0.6; bloomPass.radius = 0.5
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);
        }

        // Particles & Materials
        function createTextures() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, 128, 128); ctx.fillStyle = '#aa0000'; ctx.beginPath();
            for (let i = -128; i < 256; i += 32) { ctx.moveTo(i, 0); ctx.lineTo(i + 32, 128); ctx.lineTo(i + 16, 128); ctx.lineTo(i - 16, 0); } ctx.fill();
            caneTexture = new THREE.CanvasTexture(canvas); caneTexture.colorSpace = THREE.SRGBColorSpace; caneTexture.wrapS = THREE.RepeatWrapping; caneTexture.wrapT = THREE.RepeatWrapping; caneTexture.repeat.set(3, 3);
        }
        function createMaterials() {
            matLib.gold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.15, envMapIntensity: 2.5, emissive: 0x664400, emissiveIntensity: 0.2 });
            matLib.green = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, metalness: 0.4, roughness: 0.3, emissive: 0x001100, emissiveIntensity: 0.1 });
            matLib.red = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.red, metalness: 0.6, roughness: 0.2, clearcoat: 1.0, emissive: 0x330000, emissiveIntensity: 0.4 });
            matLib.pink = new THREE.MeshPhysicalMaterial({ color: CONFIG.colors.pink, metalness: 0.8, roughness: 0.1, clearcoat: 0.8, emissive: 0x550022, emissiveIntensity: 0.4 });
            matLib.white = new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.1, emissive: 0x222222, emissiveIntensity: 0.2 });
            matLib.candy = new THREE.MeshStandardMaterial({ map: caneTexture, roughness: 0.3, metalness: 0.1, emissive: 0x222222 });
            matLib.dust = new THREE.MeshBasicMaterial({ color: 0xffffee, blending: THREE.AdditiveBlending });
        }

        class Particle {
            constructor(mesh, type, isDust = false) {
                this.mesh = mesh; this.type = type; this.isDust = isDust; this.posTree = new THREE.Vector3(); this.posScatter = new THREE.Vector3();
                this.baseScale = mesh.scale.x; this.offset = Math.random() * 100; this.speed = 0.5 + Math.random();
                if (mesh.material && mesh.material.emissive) { this.baseEmissive = mesh.material.emissive.clone(); this.hasEmissive = true; }
                this.calculatePositions();
            }
            calculatePositions() {
                const h = CONFIG.particles.treeHeight; let t = Math.random();
                if (Math.random() > 0.7 && !this.isDust && this.type !== 'PHOTO') {
                    const y = (t * h) - h / 2; const rBase = CONFIG.particles.treeRadius * (1.0 - t); const angle = t * Math.PI * 2 * 6; this.posTree.set(Math.cos(angle) * rBase, y, Math.sin(angle) * rBase);
                } else {
                    t = Math.pow(t, 0.8); const y = (t * h) - h / 2; let rMax = CONFIG.particles.treeRadius * (1.0 - t); if (rMax < 0.5) rMax = 0.5;
                    const angle = Math.random() * Math.PI * 2; const r = rMax * Math.sqrt(Math.random()); this.posTree.set(Math.cos(angle) * r, y, Math.sin(angle) * r);
                }
                let rScatter = this.isDust ? (15 + Math.random() * 25) : (10 + Math.random() * 15); const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                this.posScatter.set(rScatter * Math.sin(phi) * Math.cos(theta), rScatter * Math.sin(phi) * Math.sin(theta), rScatter * Math.cos(phi));
            }

            update(dt, time, mode, focusTargetMesh) {
                let target = this.posTree; let s = this.baseScale; let lerpSpeed = 3.0;

                // Slideshow Logic
                if (mode === 'SLIDESHOW') {
                    if (this.type === 'PHOTO') {
                        if (STATE.slideshowActivePhoto) {
                            if (STATE.slideshowActivePhoto === this) {
                                const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert();
                                const camTarget = new THREE.Vector3(0, 0, CONFIG.camera.z - 15);
                                target = camTarget.applyMatrix4(invMatrix);
                                this.mesh.lookAt(camera.position);
                                s = this.baseScale * 6.0; lerpSpeed = 5.0;
                            } else {
                                target = this.posScatter.clone().multiplyScalar(1.5); s = 0.0; lerpSpeed = 5.0;
                            }
                        } else {
                            const idx = STATE.photoParticles.indexOf(this); const total = STATE.photoParticles.length;
                            if (total > 0) {
                                const radius = 14;
                                const angle = (idx / total) * Math.PI * 2 + STATE.slideshowRotation;
                                target = new THREE.Vector3(Math.cos(angle) * radius, Math.sin(time * 0.5 + idx) * 1.5, Math.sin(angle) * radius);
                                this.mesh.lookAt(camera.position); s = this.baseScale * 4.5; lerpSpeed = 4.0;
                            }
                        }
                    } else { target = this.posScatter.clone().multiplyScalar(1.2); s = 0.05; }
                }
                else if (mode === 'SCATTER') { target = this.posScatter.clone().multiplyScalar(STATE.scatterScale); }
                else if (mode === 'LETTER') { target = this.posScatter; }
                else if (mode === 'FOCUS') {
                    if (this.mesh === focusTargetMesh) {
                        const invMatrix = new THREE.Matrix4().copy(mainGroup.matrixWorld).invert(); const camPos = new THREE.Vector3(0, 0, CONFIG.camera.z - 15);
                        target = camPos.applyMatrix4(invMatrix); lerpSpeed = 6.0; this.mesh.lookAt(camera.position); s = this.baseScale * 5.0;
                    } else { target = this.posScatter; s = 0.01; }
                }

                const dest = target.clone();

                if (mode === 'TREE' || mode === 'WAITING') {
                    const noiseY = Math.sin(time * this.speed + this.offset) * 0.15; const noiseX = Math.cos(time * 0.5 * this.speed + this.offset) * 0.1; dest.y += noiseY; dest.x += noiseX;
                }

                this.mesh.position.lerp(dest, lerpSpeed * dt);

                if (this.hasEmissive && (mode === 'TREE' || mode === 'WAITING') && !this.isDust) { const blink = Math.sin(time * 2 + this.offset); this.mesh.material.emissiveIntensity = blink > 0.5 ? (1.0 + (blink - 0.5) * 4) : 0.3; }

                if (mode !== 'FOCUS' && mode !== 'SLIDESHOW') {
                    if (this.isDust) { s = this.baseScale * (0.5 + 0.5 * Math.sin(time * 3 + this.offset)); } else if ((mode === 'SCATTER' || mode === 'LETTER') && this.type === 'PHOTO') { s = this.baseScale * 2.5; }
                }
                this.mesh.scale.lerp(new THREE.Vector3(s, s, s), 5 * dt);
            }
        }

        function createGalaxyBackground() {
            const geometry = new THREE.BufferGeometry(); const count = 3000; const positions = new Float32Array(count * 3); const sizes = new Float32Array(count); const colors = new Float32Array(count * 3);
            const c1 = new THREE.Color(0x88aaff); const c2 = new THREE.Color(0xffffee); const c3 = new THREE.Color(0xffd700);
            for (let i = 0; i < count; i++) {
                const r = 60 + Math.random() * 250; const theta = Math.random() * Math.PI * 2; const phi = Math.acos(2 * Math.random() - 1);
                positions[i * 3] = r * Math.sin(phi) * Math.cos(theta); positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta); positions[i * 3 + 2] = r * Math.cos(phi);
                sizes[i] = Math.random() * 2.0; let c = Math.random(); let finalC = c < 0.6 ? c2 : (c < 0.9 ? c1 : c3); colors[i * 3] = finalC.r; colors[i * 3 + 1] = finalC.g; colors[i * 3 + 2] = finalC.b;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1)); geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ size: 1.0, transparent: true, opacity: 0.8, vertexColors: true, sizeAttenuation: true, blending: THREE.AdditiveBlending, depthWrite: false });
            bgGroup.add(new THREE.Points(geometry, material));
        }

        function createParticles() {
            const sphereGeo = new THREE.SphereGeometry(0.5, 8, 8); const boxGeo = new THREE.BoxGeometry(0.45, 0.45, 0.45);
            const curve = new THREE.CatmullRomCurve3([new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.3, 0), new THREE.Vector3(0.1, 0.5, 0), new THREE.Vector3(0.3, 0.4, 0)]);
            const candyGeo = new THREE.TubeGeometry(curve, 16, 0.08, 8, false); const dustGeo = new THREE.OctahedronGeometry(0.1, 0);
            for (let i = 0; i < CONFIG.particles.count; i++) {
                const rand = Math.random(); let mesh, type;
                if (rand < 0.35) { mesh = new THREE.Mesh(boxGeo, matLib.green); type = 'BOX'; } else if (rand < 0.70) { mesh = new THREE.Mesh(boxGeo, matLib.gold); type = 'GOLD_BOX'; } else if (rand < 0.90) { mesh = new THREE.Mesh(sphereGeo, matLib.gold); type = 'GOLD_SPHERE'; } else if (rand < 0.96) { mesh = new THREE.Mesh(sphereGeo, matLib.red); type = 'RED'; } else { mesh = new THREE.Mesh(candyGeo, matLib.candy); type = 'CANE'; }
                const s = 0.4 + Math.random() * 0.4; mesh.scale.set(s, s, s); mesh.rotation.set(Math.random() * 6, Math.random() * 6, Math.random() * 6);
                mainGroup.add(mesh); particleSystem.push(new Particle(mesh, type, false));
            }
            for (let i = 0; i < CONFIG.particles.dustCount; i++) { const mesh = new THREE.Mesh(dustGeo, matLib.dust); mesh.scale.setScalar(0.5 + Math.random()); mainGroup.add(mesh); particleSystem.push(new Particle(mesh, 'DUST', true)); }
            createStarTopper();
        }

        function createStarTopper() {
            const starGeo = new THREE.OctahedronGeometry(1.5, 0); const starMat = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffaa00, emissiveIntensity: 2.0, metalness: 1.0, roughness: 0 });
            const star = new THREE.Mesh(starGeo, starMat); star.position.set(0, CONFIG.particles.treeHeight / 2 + 1.2, 0);
            const halo = new THREE.Mesh(new THREE.PlaneGeometry(8, 8), new THREE.MeshBasicMaterial({ map: new THREE.TextureLoader().load('https://github.com/mrdoob/three.js/tree/dev/examples/textures/sprites/ball.png'), blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.5, color: 0xffaa00 }));
            star.add(halo); starGroup.add(star); STATE.starMesh = star;
        }

        function switchTheme(themeIndex) {
            STATE.currentThemeIndex = themeIndex;
            particleSystem.forEach(p => {
                if (p.isDust || p.type === 'PHOTO') return; let newMat;
                switch (themeIndex) {
                    case 0: if (p.type === 'GOLD_BOX' || p.type === 'GOLD_SPHERE') newMat = matLib.gold; else if (p.type === 'BOX') newMat = matLib.green; else if (p.type === 'RED') newMat = matLib.red; else if (p.type === 'CANE') newMat = matLib.candy; break;
                    case 1: if (p.type === 'GOLD_BOX') newMat = matLib.pink; else if (p.type === 'GOLD_SPHERE') newMat = matLib.pink; else if (p.type === 'BOX') newMat = matLib.white; else if (p.type === 'RED') newMat = matLib.gold; else if (p.type === 'CANE') newMat = matLib.candy; break;
                    case 2: if (p.type === 'GOLD_BOX') newMat = matLib.red; else if (p.type === 'GOLD_SPHERE') newMat = matLib.red; else if (p.type === 'BOX') newMat = matLib.gold; else if (p.type === 'RED') newMat = matLib.green; else if (p.type === 'CANE') newMat = matLib.candy; break;
                    case 3: if (p.type === 'GOLD_BOX') newMat = matLib.green; else if (p.type === 'GOLD_SPHERE') newMat = matLib.green; else if (p.type === 'BOX') newMat = matLib.red; else if (p.type === 'RED') newMat = matLib.gold; else if (p.type === 'CANE') newMat = matLib.candy; break;
                }
                if (newMat) p.mesh.material = newMat;
            });
        }

        // ÂÖ≥ÈîÆ‰øÆÊîπÔºömaxSize Êîπ‰∏∫ 2.5ÔºåËÆ©ÁÖßÁâáÊõ¥Â§ß
        function addPhotoToScene(texture) {
            const img = texture.image; if (!img) return;
            const aspect = img.width / img.height; const maxSize = 1.4; let photoW, photoH;
            if (aspect >= 1) { photoW = maxSize; photoH = maxSize / aspect; } else { photoH = maxSize; photoW = maxSize * aspect; }
            const frameMargin = 0.15; const group = new THREE.Group();
            const frameGeo = new THREE.BoxGeometry(photoW + frameMargin, photoH + frameMargin, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 1.0, roughness: 0.2 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            const photoGeo = new THREE.PlaneGeometry(photoW, photoH);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.06; group.add(frame); group.add(photo); photoMeshGroup.add(group);
            const p = new Particle(group, 'PHOTO', false); particleSystem.push(p); STATE.photoParticles.push(p);
        }

        // Letter Display
        function setupLetterDisplayLogic() {
            const closeLetterBtn = document.getElementById('btn-close-letter-mode');
            closeLetterBtn.addEventListener('click', (e) => { e.stopPropagation(); exitLetterMode(); });
        }
        function enterLetterMode() {
            if (STATE.mode === 'LETTER') return; STATE.mode = 'LETTER';
            const overlay = document.getElementById('letter-overlay'); const display = document.getElementById('letter-content-display'); const paper = document.querySelector('.letter-paper');
            overlay.style.display = 'flex'; requestAnimationFrame(() => { overlay.style.opacity = 1; paper.style.transform = 'translateY(0)'; });
            display.textContent = ''; display.classList.remove('cursor'); let i = 0; const content = STATE.letterContent;
            function typeWriter() { if (STATE.mode !== 'LETTER') return; if (i < content.length) { display.textContent += content.charAt(i); i++; display.scrollTop = display.scrollHeight; STATE.letterTyper = setTimeout(typeWriter, 100); } else { display.classList.remove('cursor'); } }
            STATE.letterStartTimer = setTimeout(() => { if (STATE.mode === 'LETTER') { display.classList.add('cursor'); typeWriter(); } }, 2000);
        }
        function exitLetterMode() {
            STATE.mode = 'TREE'; clearTimeout(STATE.letterTyper); clearTimeout(STATE.letterStartTimer);
            const overlay = document.getElementById('letter-overlay'); const paper = document.querySelector('.letter-paper');
            overlay.style.opacity = 0; paper.style.transform = 'translateY(20px)'; setTimeout(() => { overlay.style.display = 'none'; }, 500); STATE.spinVel.x = 0; STATE.spinVel.y = 0;
        }

        // MediaPipe & Camera Toggle Logic
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, { baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate: "GPU" }, runningMode: "VIDEO", numHands: 1 });
            video = document.getElementById('webcam'); const canvasElement = document.getElementById('webcam-preview'); canvasCtx = canvasElement.getContext('2d'); drawingUtils = new DrawingUtils(canvasCtx);

            if (navigator.mediaDevices?.getUserMedia) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "user", width: { ideal: 640 }, height: { ideal: 480 } } });
                    video.srcObject = stream;
                    video.addEventListener("loadeddata", () => {
                        video.play();
                        const videoW = video.videoWidth; const videoH = video.videoHeight; STATE.videoAspectRatio = videoW / videoH;

                        // ÂàùÂßãÂåñÂ∞∫ÂØ∏
                        const wrapper = document.getElementById('webcam-wrapper');
                        wrapper.style.width = '280px';
                        wrapper.style.height = `${280 / STATE.videoAspectRatio}px`;

                        canvasElement.width = videoW; canvasElement.height = videoH;
                        if (STATE.isCameraActive) {
                            wrapper.style.opacity = 1;
                        }
                        predictWebcam();
                    });
                } catch (e) { console.warn("ÊëÑÂÉèÂ§¥ËÆøÈóÆË¢´ÊãíÁªù", e); }
            }
        }

        let lastVideoTime = -1;
        async function predictWebcam() {
            if (!STATE.isCameraActive || !video || video.paused || video.ended) { requestAnimationFrame(predictWebcam); return; }
            const canvasElement = document.getElementById('webcam-preview');
            if (video.videoWidth && canvasElement.width !== video.videoWidth) { canvasElement.width = video.videoWidth; canvasElement.height = video.videoHeight; }
            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime; let result = null;
                if (handLandmarker) result = handLandmarker.detectForVideo(video, performance.now());
                canvasCtx.save(); canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height); canvasCtx.drawImage(video, 0, 0, canvasElement.width, canvasElement.height);
                if (result && result.landmarks && result.landmarks.length > 0) {
                    for (const landmarks of result.landmarks) { drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "#d4af37", lineWidth: 3 }); drawingUtils.drawLandmarks(landmarks, { color: "#ffffff", lineWidth: 1, radius: 3 }); }
                    processGestures(result.landmarks[0]);
                } else { STATE.hand.detected = false; }
                canvasCtx.restore();
            }
            requestAnimationFrame(predictWebcam);
        }

        function processGestures(lm) {
            if (!STATE.isCameraActive) { STATE.hand.detected = false; return; }
            STATE.hand.detected = true;
            if (STATE.mode === 'LETTER' || STATE.mode === 'WAITING' || STATE.mode === 'SLIDESHOW') return;

            const wrist = lm[0]; const thumbTip = lm[4]; const indexTip = lm[8]; const middleTip = lm[12]; const ringTip = lm[16]; const pinkyTip = lm[20]; const palm = lm[9];
            const dIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y); const dMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y); const dRing = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y); const dPinky = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y); const dThumbIndex = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
            const isOK = (dThumbIndex < 0.05) && (dMiddle > dIndex * 1.2) && (dRing > dIndex * 1.2) && (dPinky > dIndex * 1.2) && (dMiddle > 0.15);
            if (isOK) {
                const now = Date.now(); if (!STATE.letterLastTriggerTime || now - STATE.letterLastTriggerTime > 1000) { STATE.letterLastTriggerTime = now; enterLetterMode(); } return;
            }
            const isVictory = (dIndex > 0.15) && (dMiddle > 0.15) && (dRing < dIndex * 0.7) && (dPinky < dMiddle * 0.7);
            if (isVictory) {
                const now = Date.now(); if (now - STATE.gestureDebounceTimer > 2000) { let nextTheme = (STATE.currentThemeIndex + 1) % 4; switchTheme(nextTheme); STATE.gestureDebounceTimer = now; }
            }
            const isPointing = (dIndex > 0.1) && (dMiddle < dIndex * 0.7) && (dRing < dIndex * 0.7) && !isVictory;
            const avgSpread = Math.max((dIndex + dMiddle + dRing + dPinky) / 4, 0.0001); const isPalmOpen = avgSpread > CONFIG.gestures.palmOpenThreshold;
            if (isPointing) {
                STATE.mode = 'FOCUS'; const photos = particleSystem.filter(p => p.type === 'PHOTO');
                if (!STATE.wasPointing) { if (photos.length > 0) { STATE.currentPhotoIndex = (STATE.currentPhotoIndex + 1) % photos.length; STATE.focusTarget = photos[STATE.currentPhotoIndex].mesh; } else { STATE.focusTarget = STATE.starMesh; } }
                STATE.wasPointing = true; STATE.hasPalmCenter = false; STATE.gestureBaseSpread = null; STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;
            } else {
                STATE.wasPointing = false;
                if (isPalmOpen) {
                    if (STATE.mode !== 'SCATTER' || !STATE.hasPalmCenter) { STATE.palmCenter.x = palm.x; STATE.palmCenter.y = palm.y; STATE.hasPalmCenter = true; STATE.gestureBaseSpread = avgSpread; STATE.scatterScale = 1.0; }
                    STATE.mode = 'SCATTER';
                    if (STATE.gestureBaseSpread) { let rawRatio = STATE.gestureBaseSpread / avgSpread; let amplifiedScale = Math.pow(rawRatio, 2); let targetScale = THREE.MathUtils.clamp(amplifiedScale, 0.1, 5.0); STATE.scatterScale += (targetScale - STATE.scatterScale) * 0.15; }
                    const dx = palm.x - STATE.palmCenter.x; const dy = palm.y - STATE.palmCenter.y; const gain = CONFIG.gestures.sensitivity; const maxSpeed = 3.0;
                    const targetVelY = THREE.MathUtils.clamp(dx * gain, -maxSpeed, maxSpeed); const targetVelX = THREE.MathUtils.clamp(-dy * gain, -maxSpeed, maxSpeed);
                    STATE.spinVel.x += (targetVelX - STATE.spinVel.x) * 0.2; STATE.spinVel.y += (targetVelY - STATE.spinVel.y) * 0.2;
                } else {
                    STATE.mode = 'TREE'; STATE.hasPalmCenter = false; STATE.gestureBaseSpread = null; STATE.scatterScale = 1.0; STATE.spinVel.x *= 0.9; STATE.spinVel.y *= 0.9;
                }
            }
        }

        // Animation & Events
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta(); STATE.time = clock.elapsedTime;
            let inputX = STATE.hand.detected ? STATE.hand.x : STATE.mouse.x * 0.5;

            // Slideshow Ê®°Âºè‰∏ãÁöÑÊóãËΩ¨ÈÄªËæë
            if (STATE.mode === 'SLIDESHOW') {
                if (!STATE.isDragging && !STATE.slideshowActivePhoto) {
                    STATE.slideshowRotation += STATE.slideshowSpeed * dt;
                }
                STATE.rotation.y += 0.1 * dt;
                STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0, dt);
            }

            if (!STATE.isCameraActive && STATE.mode !== 'LETTER' && STATE.mode !== 'SLIDESHOW') {
                STATE.mode = 'TREE'; STATE.hand.detected = false;
            }

            if (STATE.mode === 'LETTER') {
                const targetTilt = Math.PI / 4; STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, targetTilt, dt * 1.5); STATE.rotation.y -= 0.1 * dt;
            }
            else if (STATE.mode === 'TREE' || STATE.mode === 'WAITING') {
                STATE.rotation.y -= 0.4 * dt; STATE.rotation.x = THREE.MathUtils.lerp(STATE.rotation.x, 0.15, dt * 2.0); mainGroup.rotation.z = THREE.MathUtils.lerp(mainGroup.rotation.z, inputX * 0.1, dt * 2);
            }
            else if (STATE.mode === 'SCATTER') {
                STATE.rotation.y += STATE.spinVel.y * dt; STATE.rotation.x += STATE.spinVel.x * dt;
                if (!STATE.hand.detected) { STATE.spinVel.x *= 0.95; STATE.spinVel.y *= 0.95; }
            }
            mainGroup.rotation.y = STATE.rotation.y; mainGroup.rotation.x = STATE.rotation.x; bgGroup.rotation.y -= 0.05 * dt;
            if (STATE.starMesh) { STATE.starMesh.rotation.y -= dt; STATE.starMesh.rotation.z = Math.sin(STATE.time) * 0.2; const scale = 1.0 + Math.sin(STATE.time * 2) * 0.1; STATE.starMesh.scale.set(scale, scale, scale); }
            for (let i = 0, l = particleSystem.length; i < l; i++) { particleSystem[i].update(dt, STATE.time, STATE.mode, STATE.focusTarget); }
            composer.render();
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
            });
            const startBtn = document.getElementById('btn-start-experience');
            const startScreen = document.getElementById('start-screen');
            const audioEl = document.getElementById('bg-music');
            const loveTimer = document.getElementById('love-timer-container');
            startBtn.addEventListener('click', () => {
                audioEl.play().catch(console.warn); startScreen.classList.add('fade-out'); setTimeout(() => startScreen.style.display = 'none', 1500); loveTimer.style.display = 'block'; STATE.mode = 'TREE';
            });

            // ==========================================
            // Êñ∞Â¢ûÔºöÁÇπÂáªÁõ¥Êé•ÂÖ≥Èó≠/ÂºÄÂêØÔºåÈïøÊåâÊãñÊãΩÂ§ßÂ∞è
            // ==========================================
            const toggleCamBtn = document.getElementById('btn-toggle-camera');
            const webcamWrapper = document.getElementById('webcam-wrapper');

            // ÊåâÈíÆÈÄªËæëÔºöÊéßÂà∂ÊòæÁ§∫/ÈöêËóè
            toggleCamBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                STATE.isCameraActive = !STATE.isCameraActive;
                if (STATE.isCameraActive) {
                    toggleCamBtn.textContent = 'ÂÖ≥Èó≠ÊëÑÂÉèÂ§¥'; toggleCamBtn.classList.add('active');
                    webcamWrapper.style.display = 'flex'; // ÊÅ¢Â§çÊòæÁ§∫
                    requestAnimationFrame(() => webcamWrapper.style.opacity = 1);
                    predictWebcam();
                } else {
                    toggleCamBtn.textContent = 'ÂºÄÂêØÊëÑÂÉèÂ§¥'; toggleCamBtn.classList.remove('active');
                    webcamWrapper.style.display = 'none'; // Áõ¥Êé•Ê∂àÂ§±
                    webcamWrapper.style.opacity = 0;
                    STATE.hand.detected = false;
                }
            });

            // ÈïøÊåâÊãñÊãΩÈÄªËæë
            let resizeTimeout;

            // Èº†Ê†á/ÊâãÊåáÊåâ‰∏ã
            function startResizeCheck(e) {
                // Â¶ÇÊûúÊòØÁßªÂä®Á´ØÔºåe.touches[0]
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;

                // 500ms ÂêéËß¶ÂèëË∞ÉÊï¥Ê®°Âºè
                resizeTimeout = setTimeout(() => {
                    STATE.webcamResize.isResizing = true;
                    STATE.webcamResize.startX = clientX;
                    STATE.webcamResize.startWidth = webcamWrapper.offsetWidth;
                    webcamWrapper.classList.add('resizing');
                }, 500);
            }

            // ÁßªÂä®‰∏≠
            function onResizeMove(e) {
                if (!STATE.webcamResize.isResizing) return;

                // Èò≤Ê≠¢ÈªòËÆ§Ë°å‰∏∫ÔºàÊØîÂ¶ÇÁßªÂä®Á´ØÊªöÂä®Ôºâ
                e.preventDefault();

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;

                // ÂæÄÂ∑¶ÊªëÊòØÂèòÂ§ßÔºàÂõ†‰∏∫ÊëÑÂÉèÂ§¥Âú®Âè≥ËæπÔºâÔºåÂæÄÂè≥ÊªëÊòØÂèòÂ∞è
                // delta > 0 (Âè≥Êªë) -> ÂèòÂ∞è
                // delta < 0 (Â∑¶Êªë) -> ÂèòÂ§ß
                const deltaX = STATE.webcamResize.startX - clientX;

                let newWidth = STATE.webcamResize.startWidth + deltaX;
                // ÈôêÂà∂Â§ßÂ∞èËåÉÂõ¥
                newWidth = Math.max(150, Math.min(newWidth, 600));

                webcamWrapper.style.width = `${newWidth}px`;
                webcamWrapper.style.height = `${newWidth / STATE.videoAspectRatio}px`;
            }

            // ÁªìÊùü
            function endResizeCheck() {
                clearTimeout(resizeTimeout);
                if (STATE.webcamResize.isResizing) {
                    STATE.webcamResize.isResizing = false;
                    webcamWrapper.classList.remove('resizing');
                }
            }

            webcamWrapper.addEventListener('mousedown', startResizeCheck);
            webcamWrapper.addEventListener('touchstart', startResizeCheck);

            window.addEventListener('mousemove', onResizeMove);
            window.addEventListener('touchmove', onResizeMove, { passive: false });

            window.addEventListener('mouseup', endResizeCheck);
            window.addEventListener('touchend', endResizeCheck);


            // ÂπªÁÅØÁâá‰∫§‰∫íÈÄªËæë
            const canvasContainer = document.getElementById('canvas-container');
            function onPointerDown(event) {
                if (STATE.mode !== 'SLIDESHOW') return;
                STATE.isDragging = true;
                STATE.lastMouseX = event.clientX;
            }
            function onPointerMove(event) {
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
                pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
                if (STATE.mode !== 'SLIDESHOW' || !STATE.isDragging || STATE.slideshowActivePhoto) return;
                const deltaX = event.clientX - STATE.lastMouseX;
                STATE.lastMouseX = event.clientX;
                STATE.slideshowRotation += deltaX * 0.005;
            }
            function onPointerUp() { STATE.isDragging = false; }
            function onClick(event) {
                if (STATE.mode !== 'SLIDESHOW') return;
                raycaster.setFromCamera(pointer, camera);
                const photoMeshes = [];
                STATE.photoParticles.forEach(p => { p.mesh.children.forEach(child => photoMeshes.push(child)); });
                const intersects = raycaster.intersectObjects(photoMeshes);
                if (intersects.length > 0) {
                    const hitObj = intersects[0].object; const parentGroup = hitObj.parent;
                    const clickedParticle = STATE.photoParticles.find(p => p.mesh === parentGroup);
                    if (clickedParticle) {
                        if (STATE.slideshowActivePhoto === clickedParticle) { STATE.slideshowActivePhoto = null; }
                        else { STATE.slideshowActivePhoto = clickedParticle; }
                    }
                } else {
                    if (STATE.slideshowActivePhoto) { STATE.slideshowActivePhoto = null; }
                }
            }
            canvasContainer.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            canvasContainer.addEventListener('click', onClick);


            const slideshowBtn = document.getElementById('btn-slideshow');
            if (slideshowBtn) {
                slideshowBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (STATE.mode === 'SLIDESHOW') { STATE.mode = 'TREE'; slideshowBtn.classList.remove('active'); slideshowBtn.textContent = 'ÁÇπÊª¥Áû¨Èó¥'; }
                    else { STATE.mode = 'SLIDESHOW'; slideshowBtn.classList.add('active'); slideshowBtn.textContent = 'ÈÄÄÂá∫Â∑°Êºî'; }
                });
            }
            const fullscreenBtn = document.getElementById('btn-fullscreen');
            if (fullscreenBtn) {
                fullscreenBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (!document.fullscreenElement) { document.documentElement.requestFullscreen().catch(err => console.warn(err)); }
                    else { if (document.exitFullscreen) document.exitFullscreen(); }
                });
                document.addEventListener('fullscreenchange', () => {
                    if (document.fullscreenElement) { fullscreenBtn.textContent = 'ÂèñÊ∂àÂÖ®Â±è'; document.getElementById('top-right-controls').style.display = 'none'; }
                    else { fullscreenBtn.textContent = 'ÂÖ®Â±èÊòæÁ§∫'; document.getElementById('top-right-controls').style.display = 'flex'; }
                });
            }
        }
        init();
    </script>
</body>

</html>
